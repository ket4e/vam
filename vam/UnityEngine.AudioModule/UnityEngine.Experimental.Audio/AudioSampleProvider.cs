using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.Audio;

/// <summary>
///   <para>Provides access to the audio samples generated by Unity objects such as VideoPlayer.</para>
/// </summary>
[StaticAccessor("AudioSampleProviderBindings", StaticAccessorType.DoubleColon)]
[NativeType(Header = "Modules/Audio/Public/ScriptBindings/AudioSampleProvider.bindings.h")]
public class AudioSampleProvider : IDisposable
{
	/// <summary>
	///   <para>Type that represents the native function pointer for consuming sample frames.</para>
	/// </summary>
	/// <param name="providerId">Id of the provider. See Experimental.Audio.AudioSampleProvider.id.</param>
	/// <param name="interleavedSampleFrames">Pointer to the sample frames buffer to fill. The actual C type is float*.</param>
	/// <param name="sampleFrameCount">Number of sample frames that can be written into interleavedSampleFrames.</param>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate uint ConsumeSampleFramesNativeFunction(uint providerId, IntPtr interleavedSampleFrames, uint sampleFrameCount);

	/// <summary>
	///   <para>Delegate for sample frame events.</para>
	/// </summary>
	/// <param name="provider">Provider emitting the event.</param>
	/// <param name="sampleFrameCount">How many sample frames are available, or were dropped, depending on the event.</param>
	public delegate void SampleFramesHandler(AudioSampleProvider provider, uint sampleFrameCount);

	/// <summary>
	///   <para>Type that represents the native function pointer for handling sample frame events.</para>
	/// </summary>
	/// <param name="userData">User data specified when the handler was set. The actual C type is void*.</param>
	/// <param name="providerId">Id of the provider. See Experimental.Audio.AudioSampleProvider.id.</param>
	/// <param name="sampleFrameCount">Number of sample frames available or overflowed, depending on event type.</param>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void SampleFramesEventNativeFunction(IntPtr userData, uint providerId, uint sampleFrameCount);

	private ConsumeSampleFramesNativeFunction m_ConsumeSampleFramesNativeFunction;

	/// <summary>
	///   <para>Unique identifier for this instance.</para>
	/// </summary>
	public uint id { get; private set; }

	/// <summary>
	///   <para>Index of the track in the object that created this provider.</para>
	/// </summary>
	public ushort trackIndex { get; private set; }

	/// <summary>
	///   <para>Object where this provider came from.</para>
	/// </summary>
	public Object owner { get; private set; }

	/// <summary>
	///   <para>True if the object is valid.</para>
	/// </summary>
	public bool valid => InternalIsValid(id);

	/// <summary>
	///   <para>The number of audio channels per sample frame.</para>
	/// </summary>
	public ushort channelCount { get; private set; }

	/// <summary>
	///   <para>The expected playback rate for the sample frames produced by this class.</para>
	/// </summary>
	public uint sampleRate { get; private set; }

	/// <summary>
	///   <para>The maximum number of sample frames that can be accumulated inside the internal buffer before an overflow event is emitted.</para>
	/// </summary>
	public uint maxSampleFrameCount => InternalGetMaxSampleFrameCount(id);

	/// <summary>
	///   <para>Number of sample frames available for consuming with Experimental.Audio.AudioSampleProvider.ConsumeSampleFrames.</para>
	/// </summary>
	public uint availableSampleFrameCount => InternalGetAvailableSampleFrameCount(id);

	/// <summary>
	///   <para>Number of sample frames that can still be written to by the sample producer before overflowing.</para>
	/// </summary>
	public uint freeSampleFrameCount => InternalGetFreeSampleFrameCount(id);

	/// <summary>
	///   <para>Then the free sample count falls below this threshold, the Experimental.Audio.AudioSampleProvider.sampleFramesAvailable event and associated native is emitted.</para>
	/// </summary>
	public uint freeSampleFrameCountLowThreshold
	{
		get
		{
			return InternalGetFreeSampleFrameCountLowThreshold(id);
		}
		set
		{
			InternalSetFreeSampleFrameCountLowThreshold(id, value);
		}
	}

	/// <summary>
	///   <para>Enables the Experimental.Audio.AudioSampleProvider.sampleFramesAvailable events.</para>
	/// </summary>
	public bool enableSampleFramesAvailableEvents
	{
		get
		{
			return InternalGetEnableSampleFramesAvailableEvents(id);
		}
		set
		{
			InternalSetEnableSampleFramesAvailableEvents(id, value);
		}
	}

	/// <summary>
	///   <para>If true, buffers produced by ConsumeSampleFrames will get padded when silence if there are less available than asked for. Otherwise, the extra sample frames in the buffer will be left unchanged.</para>
	/// </summary>
	public bool enableSilencePadding
	{
		get
		{
			return InternalGetEnableSilencePadding(id);
		}
		set
		{
			InternalSetEnableSilencePadding(id, value);
		}
	}

	/// <summary>
	///   <para>Pointer to the native function that provides access to audio sample frames.</para>
	/// </summary>
	public static ConsumeSampleFramesNativeFunction consumeSampleFramesNativeFunction => (ConsumeSampleFramesNativeFunction)Marshal.GetDelegateForFunctionPointer(InternalGetConsumeSampleFramesNativeFunctionPtr(), typeof(ConsumeSampleFramesNativeFunction));

	public event SampleFramesHandler sampleFramesAvailable;

	public event SampleFramesHandler sampleFramesOverflow;

	private AudioSampleProvider(uint providerId, Object ownerObj, ushort trackIdx)
	{
		owner = ownerObj;
		id = providerId;
		trackIndex = trackIdx;
		m_ConsumeSampleFramesNativeFunction = (ConsumeSampleFramesNativeFunction)Marshal.GetDelegateForFunctionPointer(InternalGetConsumeSampleFramesNativeFunctionPtr(), typeof(ConsumeSampleFramesNativeFunction));
		ushort chCount = 0;
		uint sRate = 0u;
		InternalGetFormatInfo(providerId, out chCount, out sRate);
		channelCount = chCount;
		sampleRate = sRate;
		InternalSetScriptingPtr(providerId, this);
	}

	[VisibleToOtherModules]
	internal static AudioSampleProvider Lookup(uint providerId, Object ownerObj, ushort trackIndex)
	{
		AudioSampleProvider audioSampleProvider = InternalGetScriptingPtr(providerId);
		if (audioSampleProvider != null)
		{
			return audioSampleProvider;
		}
		return new AudioSampleProvider(providerId, ownerObj, trackIndex);
	}

	~AudioSampleProvider()
	{
		Dispose();
	}

	/// <summary>
	///   <para>Release internal resources. Inherited from IDisposable.</para>
	/// </summary>
	public void Dispose()
	{
		if (id != 0)
		{
			InternalSetScriptingPtr(id, null);
			id = 0u;
		}
		GC.SuppressFinalize(this);
	}

	public unsafe uint ConsumeSampleFrames(NativeArray<float> sampleFrames)
	{
		if (channelCount == 0)
		{
			return 0u;
		}
		return m_ConsumeSampleFramesNativeFunction(id, (IntPtr)sampleFrames.GetUnsafePtr(), (uint)sampleFrames.Length / (uint)channelCount);
	}

	public void SetSampleFramesAvailableNativeHandler(SampleFramesEventNativeFunction handler, IntPtr userData)
	{
		InternalSetSampleFramesAvailableNativeHandler(id, Marshal.GetFunctionPointerForDelegate(handler), userData);
	}

	/// <summary>
	///   <para>Clear the native handler set with Experimental.Audio.AudioSampleProvider.SetSampleFramesAvailableNativeHandler.</para>
	/// </summary>
	public void ClearSampleFramesAvailableNativeHandler()
	{
		InternalClearSampleFramesAvailableNativeHandler(id);
	}

	public void SetSampleFramesOverflowNativeHandler(SampleFramesEventNativeFunction handler, IntPtr userData)
	{
		InternalSetSampleFramesOverflowNativeHandler(id, Marshal.GetFunctionPointerForDelegate(handler), userData);
	}

	/// <summary>
	///   <para>Clear the native handler set with Experimental.Audio.AudioSampleProvider.SetSampleFramesOverflowNativeHandler.</para>
	/// </summary>
	public void ClearSampleFramesOverflowNativeHandler()
	{
		InternalClearSampleFramesOverflowNativeHandler(id);
	}

	[RequiredByNativeCode]
	private void InvokeSampleFramesAvailable(int sampleFrameCount)
	{
		if (this.sampleFramesAvailable != null)
		{
			this.sampleFramesAvailable(this, (uint)sampleFrameCount);
		}
	}

	[RequiredByNativeCode]
	private void InvokeSampleFramesOverflow(int droppedSampleFrameCount)
	{
		if (this.sampleFramesOverflow != null)
		{
			this.sampleFramesOverflow(this, (uint)droppedSampleFrameCount);
		}
	}

	[MethodImpl(MethodImplOptions.InternalCall)]
	private static extern void InternalGetFormatInfo(uint providerId, out ushort chCount, out uint sRate);

	[MethodImpl(MethodImplOptions.InternalCall)]
	private static extern AudioSampleProvider InternalGetScriptingPtr(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern void InternalSetScriptingPtr(uint providerId, AudioSampleProvider provider);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern bool InternalIsValid(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern uint InternalGetMaxSampleFrameCount(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern uint InternalGetAvailableSampleFrameCount(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern uint InternalGetFreeSampleFrameCount(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern uint InternalGetFreeSampleFrameCountLowThreshold(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern void InternalSetFreeSampleFrameCountLowThreshold(uint providerId, uint sampleFrameCount);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern bool InternalGetEnableSampleFramesAvailableEvents(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern void InternalSetEnableSampleFramesAvailableEvents(uint providerId, bool enable);

	[MethodImpl(MethodImplOptions.InternalCall)]
	private static extern void InternalSetSampleFramesAvailableNativeHandler(uint providerId, IntPtr handler, IntPtr userData);

	[MethodImpl(MethodImplOptions.InternalCall)]
	private static extern void InternalClearSampleFramesAvailableNativeHandler(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	private static extern void InternalSetSampleFramesOverflowNativeHandler(uint providerId, IntPtr handler, IntPtr userData);

	[MethodImpl(MethodImplOptions.InternalCall)]
	private static extern void InternalClearSampleFramesOverflowNativeHandler(uint providerId);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern bool InternalGetEnableSilencePadding(uint id);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern void InternalSetEnableSilencePadding(uint id, bool enabled);

	[MethodImpl(MethodImplOptions.InternalCall)]
	[NativeMethod(IsThreadSafe = true)]
	private static extern IntPtr InternalGetConsumeSampleFramesNativeFunctionPtr();
}

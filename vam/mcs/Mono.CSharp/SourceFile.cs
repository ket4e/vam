using System;
using System.Collections.Generic;
using System.IO;
using Mono.CompilerServices.SymbolWriter;

namespace Mono.CSharp;

public class SourceFile : IEquatable<SourceFile>
{
	private struct LocationRegion : IComparable<LocationRegion>
	{
		public readonly Location Start;

		public readonly Location End;

		public LocationRegion(Location start, Location end)
		{
			Start = start;
			End = end;
		}

		public int CompareTo(LocationRegion other)
		{
			if (Start.Row == other.Start.Row)
			{
				return Start.Column.CompareTo(other.Start.Column);
			}
			return Start.Row.CompareTo(other.Start.Row);
		}

		public override string ToString()
		{
			return Start.ToString() + " - " + End.ToString();
		}
	}

	private static readonly byte[] MD5Algorith = new byte[16]
	{
		96, 166, 110, 64, 207, 100, 130, 76, 182, 240,
		66, 212, 129, 114, 167, 153
	};

	public readonly string Name;

	public readonly int Index;

	public bool AutoGenerated;

	private SourceFileEntry file;

	private byte[] algGuid;

	private byte[] checksum;

	private List<LocationRegion> hidden_lines;

	private Func<Stream> getStreamIfDynamicFile;

	public string FullPathName { get; set; }

	public byte[] Checksum => checksum;

	public bool HasChecksum => checksum != null;

	public SourceFileEntry SourceFileEntry => file;

	public SourceFile(string name, string path, int index, Func<Stream> streamIfDynamicFile = null)
	{
		Index = index;
		Name = name;
		FullPathName = path;
		getStreamIfDynamicFile = streamIfDynamicFile;
	}

	public Stream GetDataStream()
	{
		if (getStreamIfDynamicFile == null)
		{
			return File.OpenRead(Name);
		}
		return getStreamIfDynamicFile();
	}

	public void SetChecksum(byte[] checksum)
	{
		SetChecksum(MD5Algorith, checksum);
	}

	public void SetChecksum(byte[] algorithmGuid, byte[] checksum)
	{
		algGuid = algorithmGuid;
		this.checksum = checksum;
	}

	public SourceFileEntry CreateSymbolInfo(MonoSymbolFile symwriter)
	{
		if (hidden_lines != null)
		{
			hidden_lines.Sort();
		}
		file = new SourceFileEntry(symwriter, FullPathName, algGuid, checksum);
		if (AutoGenerated)
		{
			file.SetAutoGenerated();
		}
		return file;
	}

	public bool Equals(SourceFile other)
	{
		return FullPathName == other.FullPathName;
	}

	public bool IsHiddenLocation(Location loc)
	{
		if (hidden_lines == null)
		{
			return false;
		}
		List<LocationRegion> list = hidden_lines;
		Location location = loc;
		int num = list.BinarySearch(new LocationRegion(location, location));
		num = ~num;
		if (num > 0)
		{
			LocationRegion locationRegion = hidden_lines[num - 1];
			if (loc.Row < locationRegion.End.Row)
			{
				return true;
			}
		}
		return false;
	}

	public void RegisterHiddenScope(Location start, Location end)
	{
		if (hidden_lines == null)
		{
			hidden_lines = new List<LocationRegion>();
		}
		hidden_lines.Add(new LocationRegion(start, end));
	}

	public override string ToString()
	{
		return $"SourceFile ({Name}:{FullPathName}:{Index})";
	}
}

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;

namespace Mono.CSharp;

internal class CSharpCodeGenerator : CodeGenerator
{
	private IDictionary<string, string> providerOptions;

	private bool dont_write_semicolon;

	private static Hashtable keywordsTable;

	private static string[] keywords = new string[80]
	{
		"abstract", "event", "new", "struct", "as", "explicit", "null", "switch", "base", "extern",
		"this", "false", "operator", "throw", "break", "finally", "out", "true", "fixed", "override",
		"try", "case", "params", "typeof", "catch", "for", "private", "foreach", "protected", "checked",
		"goto", "public", "unchecked", "class", "if", "readonly", "unsafe", "const", "implicit", "ref",
		"continue", "in", "return", "using", "virtual", "default", "interface", "sealed", "volatile", "delegate",
		"internal", "do", "is", "sizeof", "while", "lock", "stackalloc", "else", "static", "enum",
		"namespace", "object", "bool", "byte", "float", "uint", "char", "ulong", "ushort", "decimal",
		"int", "sbyte", "short", "double", "long", "string", "void", "partial", "yield", "where"
	};

	protected IDictionary<string, string> ProviderOptions => providerOptions;

	protected override string NullToken => "null";

	public CSharpCodeGenerator()
	{
		dont_write_semicolon = false;
	}

	public CSharpCodeGenerator(IDictionary<string, string> providerOptions)
	{
		this.providerOptions = providerOptions;
	}

	protected override void GenerateArrayCreateExpression(CodeArrayCreateExpression expression)
	{
		TextWriter textWriter = base.Output;
		textWriter.Write("new ");
		CodeExpressionCollection initializers = expression.Initializers;
		CodeTypeReference codeTypeReference = expression.CreateType;
		if (initializers.Count > 0)
		{
			OutputType(codeTypeReference);
			if (expression.CreateType.ArrayRank == 0)
			{
				textWriter.Write("[]");
			}
			OutputStartBrace();
			base.Indent++;
			OutputExpressionList(initializers, newLineBetweenItems: true);
			base.Indent--;
			textWriter.Write("}");
			return;
		}
		for (CodeTypeReference arrayElementType = codeTypeReference.ArrayElementType; arrayElementType != null; arrayElementType = arrayElementType.ArrayElementType)
		{
			codeTypeReference = arrayElementType;
		}
		OutputType(codeTypeReference);
		textWriter.Write('[');
		CodeExpression sizeExpression = expression.SizeExpression;
		if (sizeExpression != null)
		{
			GenerateExpression(sizeExpression);
		}
		else
		{
			textWriter.Write(expression.Size);
		}
		textWriter.Write(']');
	}

	protected override void GenerateBaseReferenceExpression(CodeBaseReferenceExpression expression)
	{
		base.Output.Write("base");
	}

	protected override void GenerateCastExpression(CodeCastExpression expression)
	{
		TextWriter textWriter = base.Output;
		textWriter.Write("((");
		OutputType(expression.TargetType);
		textWriter.Write(")(");
		GenerateExpression(expression.Expression);
		textWriter.Write("))");
	}

	protected override void GenerateCompileUnitStart(CodeCompileUnit compileUnit)
	{
		GenerateComment(new CodeComment("------------------------------------------------------------------------------"));
		GenerateComment(new CodeComment(" <autogenerated>"));
		GenerateComment(new CodeComment("     This code was generated by a tool."));
		GenerateComment(new CodeComment("     Mono Runtime Version: " + Environment.Version));
		GenerateComment(new CodeComment(string.Empty));
		GenerateComment(new CodeComment("     Changes to this file may cause incorrect behavior and will be lost if "));
		GenerateComment(new CodeComment("     the code is regenerated."));
		GenerateComment(new CodeComment(" </autogenerated>"));
		GenerateComment(new CodeComment("------------------------------------------------------------------------------"));
		base.Output.WriteLine();
		base.GenerateCompileUnitStart(compileUnit);
	}

	protected override void GenerateCompileUnit(CodeCompileUnit compileUnit)
	{
		GenerateCompileUnitStart(compileUnit);
		if (compileUnit.AssemblyCustomAttributes.Count > 0)
		{
			OutputAttributes(compileUnit.AssemblyCustomAttributes, "assembly: ", inline: false);
			base.Output.WriteLine(string.Empty);
		}
		foreach (CodeNamespace @namespace in compileUnit.Namespaces)
		{
			GenerateNamespace(@namespace);
		}
		GenerateCompileUnitEnd(compileUnit);
	}

	protected override void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
	{
		base.Output.Write("default(");
		OutputType(e.Type);
		base.Output.Write(')');
	}

	protected override void GenerateDelegateCreateExpression(CodeDelegateCreateExpression expression)
	{
		TextWriter textWriter = base.Output;
		textWriter.Write("new ");
		OutputType(expression.DelegateType);
		textWriter.Write('(');
		CodeExpression targetObject = expression.TargetObject;
		if (targetObject != null)
		{
			GenerateExpression(targetObject);
			base.Output.Write('.');
		}
		textWriter.Write(GetSafeName(expression.MethodName));
		textWriter.Write(')');
	}

	protected override void GenerateFieldReferenceExpression(CodeFieldReferenceExpression expression)
	{
		CodeExpression targetObject = expression.TargetObject;
		if (targetObject != null)
		{
			GenerateExpression(targetObject);
			base.Output.Write('.');
		}
		base.Output.Write(GetSafeName(expression.FieldName));
	}

	protected override void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression expression)
	{
		base.Output.Write(GetSafeName(expression.ParameterName));
	}

	protected override void GenerateVariableReferenceExpression(CodeVariableReferenceExpression expression)
	{
		base.Output.Write(GetSafeName(expression.VariableName));
	}

	protected override void GenerateIndexerExpression(CodeIndexerExpression expression)
	{
		TextWriter textWriter = base.Output;
		GenerateExpression(expression.TargetObject);
		textWriter.Write('[');
		OutputExpressionList(expression.Indices);
		textWriter.Write(']');
	}

	protected override void GenerateArrayIndexerExpression(CodeArrayIndexerExpression expression)
	{
		TextWriter textWriter = base.Output;
		GenerateExpression(expression.TargetObject);
		textWriter.Write('[');
		OutputExpressionList(expression.Indices);
		textWriter.Write(']');
	}

	protected override void GenerateSnippetExpression(CodeSnippetExpression expression)
	{
		base.Output.Write(expression.Value);
	}

	protected override void GenerateMethodInvokeExpression(CodeMethodInvokeExpression expression)
	{
		TextWriter textWriter = base.Output;
		GenerateMethodReferenceExpression(expression.Method);
		textWriter.Write('(');
		OutputExpressionList(expression.Parameters);
		textWriter.Write(')');
	}

	protected override void GenerateMethodReferenceExpression(CodeMethodReferenceExpression expression)
	{
		if (expression.TargetObject != null)
		{
			GenerateExpression(expression.TargetObject);
			base.Output.Write('.');
		}
		base.Output.Write(GetSafeName(expression.MethodName));
		if (expression.TypeArguments.Count > 0)
		{
			base.Output.Write(GetTypeArguments(expression.TypeArguments));
		}
	}

	protected override void GenerateEventReferenceExpression(CodeEventReferenceExpression expression)
	{
		if (expression.TargetObject != null)
		{
			GenerateExpression(expression.TargetObject);
			base.Output.Write('.');
		}
		base.Output.Write(GetSafeName(expression.EventName));
	}

	protected override void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression expression)
	{
		if (expression.TargetObject != null)
		{
			GenerateExpression(expression.TargetObject);
		}
		base.Output.Write('(');
		OutputExpressionList(expression.Parameters);
		base.Output.Write(')');
	}

	protected override void GenerateObjectCreateExpression(CodeObjectCreateExpression expression)
	{
		base.Output.Write("new ");
		OutputType(expression.CreateType);
		base.Output.Write('(');
		OutputExpressionList(expression.Parameters);
		base.Output.Write(')');
	}

	protected override void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression expression)
	{
		CodeExpression targetObject = expression.TargetObject;
		if (targetObject != null)
		{
			GenerateExpression(targetObject);
			base.Output.Write('.');
		}
		base.Output.Write(GetSafeName(expression.PropertyName));
	}

	protected override void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression expression)
	{
		base.Output.Write("value");
	}

	protected override void GenerateThisReferenceExpression(CodeThisReferenceExpression expression)
	{
		base.Output.Write("this");
	}

	protected override void GenerateExpressionStatement(CodeExpressionStatement statement)
	{
		GenerateExpression(statement.Expression);
		if (!dont_write_semicolon)
		{
			base.Output.WriteLine(';');
		}
	}

	protected override void GenerateIterationStatement(CodeIterationStatement statement)
	{
		TextWriter textWriter = base.Output;
		dont_write_semicolon = true;
		textWriter.Write("for (");
		GenerateStatement(statement.InitStatement);
		textWriter.Write("; ");
		GenerateExpression(statement.TestExpression);
		textWriter.Write("; ");
		GenerateStatement(statement.IncrementStatement);
		textWriter.Write(")");
		dont_write_semicolon = false;
		OutputStartBrace();
		base.Indent++;
		GenerateStatements(statement.Statements);
		base.Indent--;
		textWriter.WriteLine('}');
	}

	protected override void GenerateThrowExceptionStatement(CodeThrowExceptionStatement statement)
	{
		base.Output.Write("throw");
		if (statement.ToThrow != null)
		{
			base.Output.Write(' ');
			GenerateExpression(statement.ToThrow);
		}
		base.Output.WriteLine(";");
	}

	protected override void GenerateComment(CodeComment comment)
	{
		TextWriter textWriter = base.Output;
		string text = null;
		text = ((!comment.DocComment) ? "//" : "///");
		textWriter.Write(text);
		textWriter.Write(' ');
		string text2 = comment.Text;
		for (int i = 0; i < text2.Length; i++)
		{
			textWriter.Write(text2[i]);
			if (text2[i] == '\r')
			{
				if (i >= text2.Length - 1 || text2[i + 1] != '\n')
				{
					textWriter.Write(text);
				}
			}
			else if (text2[i] == '\n')
			{
				textWriter.Write(text);
			}
		}
		textWriter.WriteLine();
	}

	protected override void GenerateMethodReturnStatement(CodeMethodReturnStatement statement)
	{
		TextWriter textWriter = base.Output;
		if (statement.Expression != null)
		{
			textWriter.Write("return ");
			GenerateExpression(statement.Expression);
			textWriter.WriteLine(";");
		}
		else
		{
			textWriter.WriteLine("return;");
		}
	}

	protected override void GenerateConditionStatement(CodeConditionStatement statement)
	{
		TextWriter textWriter = base.Output;
		textWriter.Write("if (");
		GenerateExpression(statement.Condition);
		textWriter.Write(")");
		OutputStartBrace();
		base.Indent++;
		GenerateStatements(statement.TrueStatements);
		base.Indent--;
		CodeStatementCollection falseStatements = statement.FalseStatements;
		if (falseStatements.Count > 0)
		{
			textWriter.Write('}');
			if (base.Options.ElseOnClosing)
			{
				textWriter.Write(' ');
			}
			else
			{
				textWriter.WriteLine();
			}
			textWriter.Write("else");
			OutputStartBrace();
			base.Indent++;
			GenerateStatements(falseStatements);
			base.Indent--;
		}
		textWriter.WriteLine('}');
	}

	protected override void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement statement)
	{
		TextWriter textWriter = base.Output;
		CodeGeneratorOptions codeGeneratorOptions = base.Options;
		textWriter.Write("try");
		OutputStartBrace();
		base.Indent++;
		GenerateStatements(statement.TryStatements);
		base.Indent--;
		foreach (CodeCatchClause catchClause in statement.CatchClauses)
		{
			textWriter.Write('}');
			if (codeGeneratorOptions.ElseOnClosing)
			{
				textWriter.Write(' ');
			}
			else
			{
				textWriter.WriteLine();
			}
			textWriter.Write("catch (");
			OutputTypeNamePair(catchClause.CatchExceptionType, GetSafeName(catchClause.LocalName));
			textWriter.Write(")");
			OutputStartBrace();
			base.Indent++;
			GenerateStatements(catchClause.Statements);
			base.Indent--;
		}
		CodeStatementCollection finallyStatements = statement.FinallyStatements;
		if (finallyStatements.Count > 0)
		{
			textWriter.Write('}');
			if (codeGeneratorOptions.ElseOnClosing)
			{
				textWriter.Write(' ');
			}
			else
			{
				textWriter.WriteLine();
			}
			textWriter.Write("finally");
			OutputStartBrace();
			base.Indent++;
			GenerateStatements(finallyStatements);
			base.Indent--;
		}
		textWriter.WriteLine('}');
	}

	protected override void GenerateAssignStatement(CodeAssignStatement statement)
	{
		TextWriter textWriter = base.Output;
		GenerateExpression(statement.Left);
		textWriter.Write(" = ");
		GenerateExpression(statement.Right);
		if (!dont_write_semicolon)
		{
			textWriter.WriteLine(';');
		}
	}

	protected override void GenerateAttachEventStatement(CodeAttachEventStatement statement)
	{
		TextWriter textWriter = base.Output;
		GenerateEventReferenceExpression(statement.Event);
		textWriter.Write(" += ");
		GenerateExpression(statement.Listener);
		textWriter.WriteLine(';');
	}

	protected override void GenerateRemoveEventStatement(CodeRemoveEventStatement statement)
	{
		TextWriter textWriter = base.Output;
		GenerateEventReferenceExpression(statement.Event);
		textWriter.Write(" -= ");
		GenerateExpression(statement.Listener);
		textWriter.WriteLine(';');
	}

	protected override void GenerateGotoStatement(CodeGotoStatement statement)
	{
		TextWriter textWriter = base.Output;
		textWriter.Write("goto ");
		textWriter.Write(GetSafeName(statement.Label));
		textWriter.WriteLine(";");
	}

	protected override void GenerateLabeledStatement(CodeLabeledStatement statement)
	{
		base.Indent--;
		base.Output.Write(statement.Label);
		base.Output.WriteLine(":");
		base.Indent++;
		if (statement.Statement != null)
		{
			GenerateStatement(statement.Statement);
		}
	}

	protected override void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement statement)
	{
		TextWriter textWriter = base.Output;
		OutputTypeNamePair(statement.Type, GetSafeName(statement.Name));
		CodeExpression initExpression = statement.InitExpression;
		if (initExpression != null)
		{
			textWriter.Write(" = ");
			GenerateExpression(initExpression);
		}
		if (!dont_write_semicolon)
		{
			textWriter.WriteLine(';');
		}
	}

	protected override void GenerateLinePragmaStart(CodeLinePragma linePragma)
	{
		base.Output.WriteLine();
		base.Output.Write("#line ");
		base.Output.Write(linePragma.LineNumber);
		base.Output.Write(" \"");
		base.Output.Write(linePragma.FileName);
		base.Output.Write("\"");
		base.Output.WriteLine();
	}

	protected override void GenerateLinePragmaEnd(CodeLinePragma linePragma)
	{
		base.Output.WriteLine();
		base.Output.WriteLine("#line default");
		base.Output.WriteLine("#line hidden");
	}

	protected override void GenerateEvent(CodeMemberEvent eventRef, CodeTypeDeclaration declaration)
	{
		if (!base.IsCurrentDelegate && !base.IsCurrentEnum)
		{
			OutputAttributes(eventRef.CustomAttributes, null, inline: false);
			if (eventRef.PrivateImplementationType == null)
			{
				OutputMemberAccessModifier(eventRef.Attributes);
			}
			base.Output.Write("event ");
			if (eventRef.PrivateImplementationType != null)
			{
				OutputTypeNamePair(eventRef.Type, eventRef.PrivateImplementationType.BaseType + "." + eventRef.Name);
			}
			else
			{
				OutputTypeNamePair(eventRef.Type, GetSafeName(eventRef.Name));
			}
			base.Output.WriteLine(';');
		}
	}

	protected override void GenerateField(CodeMemberField field)
	{
		if (!base.IsCurrentDelegate && !base.IsCurrentInterface)
		{
			TextWriter textWriter = base.Output;
			OutputAttributes(field.CustomAttributes, null, inline: false);
			if (base.IsCurrentEnum)
			{
				base.Output.Write(GetSafeName(field.Name));
			}
			else
			{
				MemberAttributes attributes = field.Attributes;
				OutputMemberAccessModifier(attributes);
				OutputVTableModifier(attributes);
				OutputFieldScopeModifier(attributes);
				OutputTypeNamePair(field.Type, GetSafeName(field.Name));
			}
			CodeExpression initExpression = field.InitExpression;
			if (initExpression != null)
			{
				textWriter.Write(" = ");
				GenerateExpression(initExpression);
			}
			if (base.IsCurrentEnum)
			{
				textWriter.WriteLine(',');
			}
			else
			{
				textWriter.WriteLine(';');
			}
		}
	}

	protected override void GenerateSnippetMember(CodeSnippetTypeMember member)
	{
		base.Output.Write(member.Text);
	}

	protected override void GenerateEntryPointMethod(CodeEntryPointMethod method, CodeTypeDeclaration declaration)
	{
		OutputAttributes(method.CustomAttributes, null, inline: false);
		base.Output.Write("public static ");
		OutputType(method.ReturnType);
		base.Output.Write(" Main()");
		OutputStartBrace();
		base.Indent++;
		GenerateStatements(method.Statements);
		base.Indent--;
		base.Output.WriteLine("}");
	}

	protected override void GenerateMethod(CodeMemberMethod method, CodeTypeDeclaration declaration)
	{
		if (base.IsCurrentDelegate || base.IsCurrentEnum)
		{
			return;
		}
		TextWriter textWriter = base.Output;
		OutputAttributes(method.CustomAttributes, null, inline: false);
		OutputAttributes(method.ReturnTypeCustomAttributes, "return: ", inline: false);
		MemberAttributes attributes = method.Attributes;
		if (!base.IsCurrentInterface)
		{
			if (method.PrivateImplementationType == null)
			{
				OutputMemberAccessModifier(attributes);
				OutputVTableModifier(attributes);
				OutputMemberScopeModifier(attributes);
			}
		}
		else
		{
			OutputVTableModifier(attributes);
		}
		OutputType(method.ReturnType);
		textWriter.Write(' ');
		CodeTypeReference privateImplementationType = method.PrivateImplementationType;
		if (privateImplementationType != null)
		{
			textWriter.Write(privateImplementationType.BaseType);
			textWriter.Write('.');
		}
		textWriter.Write(GetSafeName(method.Name));
		GenerateGenericsParameters(method.TypeParameters);
		textWriter.Write('(');
		OutputParameters(method.Parameters);
		textWriter.Write(')');
		GenerateGenericsConstraints(method.TypeParameters);
		if (IsAbstract(attributes) || declaration.IsInterface)
		{
			textWriter.WriteLine(';');
			return;
		}
		OutputStartBrace();
		base.Indent++;
		GenerateStatements(method.Statements);
		base.Indent--;
		textWriter.WriteLine('}');
	}

	private static bool IsAbstract(MemberAttributes attributes)
	{
		return (attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract;
	}

	protected override void GenerateProperty(CodeMemberProperty property, CodeTypeDeclaration declaration)
	{
		if (base.IsCurrentDelegate || base.IsCurrentEnum)
		{
			return;
		}
		TextWriter textWriter = base.Output;
		OutputAttributes(property.CustomAttributes, null, inline: false);
		MemberAttributes attributes = property.Attributes;
		if (!base.IsCurrentInterface)
		{
			if (property.PrivateImplementationType == null)
			{
				OutputMemberAccessModifier(attributes);
				OutputVTableModifier(attributes);
				OutputMemberScopeModifier(attributes);
			}
		}
		else
		{
			OutputVTableModifier(attributes);
		}
		OutputType(property.Type);
		textWriter.Write(' ');
		if (!base.IsCurrentInterface && property.PrivateImplementationType != null)
		{
			textWriter.Write(property.PrivateImplementationType.BaseType);
			textWriter.Write('.');
		}
		if (string.Compare(property.Name, "Item", ignoreCase: true, CultureInfo.InvariantCulture) == 0 && property.Parameters.Count > 0)
		{
			textWriter.Write("this[");
			OutputParameters(property.Parameters);
			textWriter.Write(']');
		}
		else
		{
			textWriter.Write(GetSafeName(property.Name));
		}
		OutputStartBrace();
		base.Indent++;
		if (declaration.IsInterface || IsAbstract(property.Attributes))
		{
			if (property.HasGet)
			{
				textWriter.WriteLine("get;");
			}
			if (property.HasSet)
			{
				textWriter.WriteLine("set;");
			}
		}
		else
		{
			if (property.HasGet)
			{
				textWriter.Write("get");
				OutputStartBrace();
				base.Indent++;
				GenerateStatements(property.GetStatements);
				base.Indent--;
				textWriter.WriteLine('}');
			}
			if (property.HasSet)
			{
				textWriter.Write("set");
				OutputStartBrace();
				base.Indent++;
				GenerateStatements(property.SetStatements);
				base.Indent--;
				textWriter.WriteLine('}');
			}
		}
		base.Indent--;
		textWriter.WriteLine('}');
	}

	protected override void GenerateConstructor(CodeConstructor constructor, CodeTypeDeclaration declaration)
	{
		if (!base.IsCurrentDelegate && !base.IsCurrentEnum && !base.IsCurrentInterface)
		{
			OutputAttributes(constructor.CustomAttributes, null, inline: false);
			OutputMemberAccessModifier(constructor.Attributes);
			base.Output.Write(GetSafeName(base.CurrentTypeName) + "(");
			OutputParameters(constructor.Parameters);
			base.Output.Write(")");
			if (constructor.BaseConstructorArgs.Count > 0)
			{
				base.Output.WriteLine(" : ");
				base.Indent += 2;
				base.Output.Write("base(");
				OutputExpressionList(constructor.BaseConstructorArgs);
				base.Output.Write(')');
				base.Indent -= 2;
			}
			if (constructor.ChainedConstructorArgs.Count > 0)
			{
				base.Output.WriteLine(" : ");
				base.Indent += 2;
				base.Output.Write("this(");
				OutputExpressionList(constructor.ChainedConstructorArgs);
				base.Output.Write(')');
				base.Indent -= 2;
			}
			OutputStartBrace();
			base.Indent++;
			GenerateStatements(constructor.Statements);
			base.Indent--;
			base.Output.WriteLine('}');
		}
	}

	protected override void GenerateTypeConstructor(CodeTypeConstructor constructor)
	{
		if (!base.IsCurrentDelegate && !base.IsCurrentEnum && !base.IsCurrentInterface)
		{
			OutputAttributes(constructor.CustomAttributes, null, inline: false);
			base.Output.Write("static " + GetSafeName(base.CurrentTypeName) + "()");
			OutputStartBrace();
			base.Indent++;
			GenerateStatements(constructor.Statements);
			base.Indent--;
			base.Output.WriteLine('}');
		}
	}

	protected override void GenerateTypeStart(CodeTypeDeclaration declaration)
	{
		TextWriter textWriter = base.Output;
		OutputAttributes(declaration.CustomAttributes, null, inline: false);
		if (!base.IsCurrentDelegate)
		{
			OutputTypeAttributes(declaration);
			textWriter.Write(GetSafeName(declaration.Name));
			GenerateGenericsParameters(declaration.TypeParameters);
			IEnumerator enumerator = declaration.BaseTypes.GetEnumerator();
			if (enumerator.MoveNext())
			{
				CodeTypeReference type = (CodeTypeReference)enumerator.Current;
				textWriter.Write(" : ");
				OutputType(type);
				while (enumerator.MoveNext())
				{
					type = (CodeTypeReference)enumerator.Current;
					textWriter.Write(", ");
					OutputType(type);
				}
			}
			GenerateGenericsConstraints(declaration.TypeParameters);
			OutputStartBrace();
			base.Indent++;
		}
		else
		{
			if ((declaration.TypeAttributes & TypeAttributes.VisibilityMask) == TypeAttributes.Public)
			{
				textWriter.Write("public ");
			}
			CodeTypeDelegate codeTypeDelegate = (CodeTypeDelegate)declaration;
			textWriter.Write("delegate ");
			OutputType(codeTypeDelegate.ReturnType);
			textWriter.Write(" ");
			textWriter.Write(GetSafeName(declaration.Name));
			textWriter.Write("(");
			OutputParameters(codeTypeDelegate.Parameters);
			textWriter.WriteLine(");");
		}
	}

	protected override void GenerateTypeEnd(CodeTypeDeclaration declaration)
	{
		if (!base.IsCurrentDelegate)
		{
			base.Indent--;
			base.Output.WriteLine("}");
		}
	}

	protected override void GenerateNamespaceStart(CodeNamespace ns)
	{
		TextWriter textWriter = base.Output;
		string name = ns.Name;
		if (name != null && name.Length != 0)
		{
			textWriter.Write("namespace ");
			textWriter.Write(GetSafeName(name));
			OutputStartBrace();
			base.Indent++;
		}
	}

	protected override void GenerateNamespaceEnd(CodeNamespace ns)
	{
		string name = ns.Name;
		if (name != null && name.Length != 0)
		{
			base.Indent--;
			base.Output.WriteLine("}");
		}
	}

	protected override void GenerateNamespaceImport(CodeNamespaceImport import)
	{
		TextWriter textWriter = base.Output;
		textWriter.Write("using ");
		textWriter.Write(GetSafeName(import.Namespace));
		textWriter.WriteLine(';');
	}

	protected override void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
	{
		base.Output.Write('[');
	}

	protected override void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
	{
		base.Output.Write(']');
	}

	private void OutputStartBrace()
	{
		if (base.Options.BracingStyle == "C")
		{
			base.Output.WriteLine(string.Empty);
			base.Output.WriteLine("{");
		}
		else
		{
			base.Output.WriteLine(" {");
		}
	}

	private void OutputAttributes(CodeAttributeDeclarationCollection attributes, string prefix, bool inline)
	{
		bool flag = false;
		foreach (CodeAttributeDeclaration attribute in attributes)
		{
			if (attribute.Name == "System.ParamArrayAttribute")
			{
				flag = true;
				continue;
			}
			GenerateAttributeDeclarationsStart(attributes);
			if (prefix != null)
			{
				base.Output.Write(prefix);
			}
			OutputAttributeDeclaration(attribute);
			GenerateAttributeDeclarationsEnd(attributes);
			if (inline)
			{
				base.Output.Write(" ");
			}
			else
			{
				base.Output.WriteLine();
			}
		}
		if (flag)
		{
			if (prefix != null)
			{
				base.Output.Write(prefix);
			}
			base.Output.Write("params");
			if (inline)
			{
				base.Output.Write(" ");
			}
			else
			{
				base.Output.WriteLine();
			}
		}
	}

	private void OutputAttributeDeclaration(CodeAttributeDeclaration attribute)
	{
		base.Output.Write(attribute.Name.Replace('+', '.'));
		base.Output.Write('(');
		IEnumerator enumerator = attribute.Arguments.GetEnumerator();
		if (enumerator.MoveNext())
		{
			CodeAttributeArgument argument = (CodeAttributeArgument)enumerator.Current;
			OutputAttributeArgument(argument);
			while (enumerator.MoveNext())
			{
				base.Output.Write(", ");
				argument = (CodeAttributeArgument)enumerator.Current;
				OutputAttributeArgument(argument);
			}
		}
		base.Output.Write(')');
	}

	protected override void OutputType(CodeTypeReference type)
	{
		base.Output.Write(GetTypeOutput(type));
	}

	private void OutputVTableModifier(MemberAttributes attributes)
	{
		if ((attributes & MemberAttributes.VTableMask) == MemberAttributes.New)
		{
			base.Output.Write("new ");
		}
	}

	protected override void OutputFieldScopeModifier(MemberAttributes attributes)
	{
		switch (attributes & MemberAttributes.ScopeMask)
		{
		case MemberAttributes.Static:
			base.Output.Write("static ");
			break;
		case MemberAttributes.Const:
			base.Output.Write("const ");
			break;
		case MemberAttributes.Override:
			break;
		}
	}

	protected override void OutputMemberAccessModifier(MemberAttributes attributes)
	{
		switch (attributes & MemberAttributes.AccessMask)
		{
		case MemberAttributes.Assembly:
		case MemberAttributes.FamilyAndAssembly:
			base.Output.Write("internal ");
			break;
		case MemberAttributes.Family:
			base.Output.Write("protected ");
			break;
		case MemberAttributes.FamilyOrAssembly:
			base.Output.Write("protected internal ");
			break;
		case MemberAttributes.Private:
			base.Output.Write("private ");
			break;
		case MemberAttributes.Public:
			base.Output.Write("public ");
			break;
		}
	}

	protected override void OutputMemberScopeModifier(MemberAttributes attributes)
	{
		switch (attributes & MemberAttributes.ScopeMask)
		{
		case MemberAttributes.Abstract:
			base.Output.Write("abstract ");
			return;
		case MemberAttributes.Final:
			return;
		case MemberAttributes.Static:
			base.Output.Write("static ");
			return;
		case MemberAttributes.Override:
			base.Output.Write("override ");
			return;
		}
		MemberAttributes memberAttributes = attributes & MemberAttributes.AccessMask;
		if (memberAttributes == MemberAttributes.Assembly || memberAttributes == MemberAttributes.Family || memberAttributes == MemberAttributes.Public)
		{
			base.Output.Write("virtual ");
		}
	}

	private void OutputTypeAttributes(CodeTypeDeclaration declaration)
	{
		TextWriter textWriter = base.Output;
		TypeAttributes typeAttributes = declaration.TypeAttributes;
		switch (typeAttributes & TypeAttributes.VisibilityMask)
		{
		case TypeAttributes.Public:
		case TypeAttributes.NestedPublic:
			textWriter.Write("public ");
			break;
		case TypeAttributes.NestedPrivate:
			textWriter.Write("private ");
			break;
		case TypeAttributes.NotPublic:
		case TypeAttributes.NestedAssembly:
		case TypeAttributes.NestedFamANDAssem:
			textWriter.Write("internal ");
			break;
		case TypeAttributes.NestedFamily:
			textWriter.Write("protected ");
			break;
		case TypeAttributes.VisibilityMask:
			textWriter.Write("protected internal ");
			break;
		}
		if (declaration.IsStruct)
		{
			if (declaration.IsPartial)
			{
				textWriter.Write("partial ");
			}
			textWriter.Write("struct ");
			return;
		}
		if (declaration.IsEnum)
		{
			textWriter.Write("enum ");
			return;
		}
		if ((typeAttributes & TypeAttributes.ClassSemanticsMask) != 0)
		{
			if (declaration.IsPartial)
			{
				textWriter.Write("partial ");
			}
			textWriter.Write("interface ");
			return;
		}
		if ((typeAttributes & TypeAttributes.Sealed) != 0)
		{
			textWriter.Write("sealed ");
		}
		if ((typeAttributes & TypeAttributes.Abstract) != 0)
		{
			textWriter.Write("abstract ");
		}
		if (declaration.IsPartial)
		{
			textWriter.Write("partial ");
		}
		textWriter.Write("class ");
	}

	[System.MonoTODO("Implement missing special characters")]
	protected override string QuoteSnippetString(string value)
	{
		string text = value.Replace("\\", "\\\\");
		text = text.Replace("\"", "\\\"");
		text = text.Replace("\t", "\\t");
		text = text.Replace("\r", "\\r");
		text = text.Replace("\n", "\\n");
		return "\"" + text + "\"";
	}

	protected override void GeneratePrimitiveExpression(CodePrimitiveExpression e)
	{
		if (e.Value is char)
		{
			GenerateCharValue((char)e.Value);
		}
		else if (e.Value is ushort)
		{
			ushort num = (ushort)e.Value;
			base.Output.Write(num.ToString(CultureInfo.InvariantCulture));
		}
		else if (e.Value is uint)
		{
			uint num2 = (uint)e.Value;
			base.Output.Write(num2.ToString(CultureInfo.InvariantCulture));
			base.Output.Write("u");
		}
		else if (e.Value is ulong)
		{
			ulong num3 = (ulong)e.Value;
			base.Output.Write(num3.ToString(CultureInfo.InvariantCulture));
			base.Output.Write("ul");
		}
		else if (e.Value is sbyte)
		{
			sbyte b = (sbyte)e.Value;
			base.Output.Write(b.ToString(CultureInfo.InvariantCulture));
		}
		else
		{
			base.GeneratePrimitiveExpression(e);
		}
	}

	private void GenerateCharValue(char c)
	{
		base.Output.Write('\'');
		switch (c)
		{
		case '\0':
			base.Output.Write("\\0");
			break;
		case '\t':
			base.Output.Write("\\t");
			break;
		case '\n':
			base.Output.Write("\\n");
			break;
		case '\r':
			base.Output.Write("\\r");
			break;
		case '"':
			base.Output.Write("\\\"");
			break;
		case '\'':
			base.Output.Write("\\'");
			break;
		case '\\':
			base.Output.Write("\\\\");
			break;
		case '\u2028':
		{
			base.Output.Write("\\u");
			TextWriter textWriter2 = base.Output;
			int num2 = c;
			textWriter2.Write(num2.ToString("X4", CultureInfo.InvariantCulture));
			break;
		}
		case '\u2029':
		{
			base.Output.Write("\\u");
			TextWriter textWriter = base.Output;
			int num = c;
			textWriter.Write(num.ToString("X4", CultureInfo.InvariantCulture));
			break;
		}
		default:
			base.Output.Write(c);
			break;
		}
		base.Output.Write('\'');
	}

	protected override void GenerateSingleFloatValue(float f)
	{
		base.GenerateSingleFloatValue(f);
		base.Output.Write('F');
	}

	protected override void GenerateDecimalValue(decimal d)
	{
		base.GenerateDecimalValue(d);
		base.Output.Write('m');
	}

	protected override void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
	{
		OutputAttributes(e.CustomAttributes, null, inline: true);
		OutputDirection(e.Direction);
		OutputType(e.Type);
		base.Output.Write(' ');
		base.Output.Write(GetSafeName(e.Name));
	}

	protected override void GenerateTypeOfExpression(CodeTypeOfExpression e)
	{
		base.Output.Write("typeof(");
		OutputType(e.Type);
		base.Output.Write(")");
	}

	protected override string CreateEscapedIdentifier(string value)
	{
		if (value == null)
		{
			throw new NullReferenceException("Argument identifier is null.");
		}
		return GetSafeName(value);
	}

	protected override string CreateValidIdentifier(string value)
	{
		if (value == null)
		{
			throw new NullReferenceException();
		}
		if (keywordsTable == null)
		{
			FillKeywordTable();
		}
		if (keywordsTable.Contains(value))
		{
			return "_" + value;
		}
		return value;
	}

	protected override string GetTypeOutput(CodeTypeReference type)
	{
		if ((type.Options & CodeTypeReferenceOptions.GenericTypeParameter) != 0)
		{
			return type.BaseType;
		}
		string text = null;
		text = ((type.ArrayElementType == null) ? DetermineTypeOutput(type) : GetTypeOutput(type.ArrayElementType));
		int arrayRank = type.ArrayRank;
		if (arrayRank > 0)
		{
			text += '[';
			for (arrayRank--; arrayRank > 0; arrayRank--)
			{
				text += ',';
			}
			text += ']';
		}
		return text;
	}

	private string DetermineTypeOutput(CodeTypeReference type)
	{
		string text = null;
		string baseType = type.BaseType;
		switch (baseType.ToLower(CultureInfo.InvariantCulture))
		{
		case "system.int32":
			return "int";
		case "system.int64":
			return "long";
		case "system.int16":
			return "short";
		case "system.boolean":
			return "bool";
		case "system.char":
			return "char";
		case "system.string":
			return "string";
		case "system.object":
			return "object";
		case "system.void":
			return "void";
		case "system.byte":
			return "byte";
		case "system.sbyte":
			return "sbyte";
		case "system.decimal":
			return "decimal";
		case "system.double":
			return "double";
		case "system.single":
			return "float";
		case "system.uint16":
			return "ushort";
		case "system.uint32":
			return "uint";
		case "system.uint64":
			return "ulong";
		default:
		{
			StringBuilder stringBuilder = new StringBuilder(baseType.Length);
			if (type.Options == CodeTypeReferenceOptions.GlobalReference)
			{
				stringBuilder.Append("global::");
			}
			int num = 0;
			for (int i = 0; i < baseType.Length; i++)
			{
				switch (baseType[i])
				{
				case '`':
				{
					stringBuilder.Append(CreateEscapedIdentifier(baseType.Substring(num, i - num)));
					i++;
					int j;
					for (j = i; j < baseType.Length && char.IsDigit(baseType[j]); j++)
					{
					}
					int count = int.Parse(baseType.Substring(i, j - i));
					OutputTypeArguments(type.TypeArguments, stringBuilder, count);
					i = j;
					if (i < baseType.Length && (baseType[i] == '+' || baseType[i] == '.'))
					{
						stringBuilder.Append('.');
						i++;
					}
					num = i;
					break;
				}
				case '+':
				case '.':
					stringBuilder.Append(CreateEscapedIdentifier(baseType.Substring(num, i - num)));
					stringBuilder.Append('.');
					i++;
					num = i;
					break;
				}
			}
			if (num < baseType.Length)
			{
				stringBuilder.Append(CreateEscapedIdentifier(baseType.Substring(num)));
			}
			return stringBuilder.ToString();
		}
		}
	}

	private static bool is_identifier_start_character(char c)
	{
		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == '@' || char.IsLetter(c);
	}

	private static bool is_identifier_part_character(char c)
	{
		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9') || char.IsLetter(c);
	}

	protected override bool IsValidIdentifier(string identifier)
	{
		if (identifier == null || identifier.Length == 0)
		{
			return false;
		}
		if (keywordsTable == null)
		{
			FillKeywordTable();
		}
		if (keywordsTable.Contains(identifier))
		{
			return false;
		}
		if (!is_identifier_start_character(identifier[0]))
		{
			return false;
		}
		for (int i = 1; i < identifier.Length; i++)
		{
			if (!is_identifier_part_character(identifier[i]))
			{
				return false;
			}
		}
		return true;
	}

	protected override bool Supports(GeneratorSupport supports)
	{
		return true;
	}

	protected override void GenerateDirectives(CodeDirectiveCollection directives)
	{
		foreach (CodeDirective directive in directives)
		{
			if (directive is CodeChecksumPragma)
			{
				GenerateCodeChecksumPragma((CodeChecksumPragma)directive);
				continue;
			}
			if (directive is CodeRegionDirective)
			{
				GenerateCodeRegionDirective((CodeRegionDirective)directive);
				continue;
			}
			throw new NotImplementedException("Unknown CodeDirective");
		}
	}

	private void GenerateCodeChecksumPragma(CodeChecksumPragma pragma)
	{
		base.Output.Write("#pragma checksum ");
		base.Output.Write(QuoteSnippetString(pragma.FileName));
		base.Output.Write(" \"");
		base.Output.Write(pragma.ChecksumAlgorithmId.ToString("B"));
		base.Output.Write("\" \"");
		if (pragma.ChecksumData != null)
		{
			byte[] checksumData = pragma.ChecksumData;
			foreach (byte b in checksumData)
			{
				base.Output.Write(b.ToString("X2"));
			}
		}
		base.Output.WriteLine("\"");
	}

	private void GenerateCodeRegionDirective(CodeRegionDirective region)
	{
		switch (region.RegionMode)
		{
		case CodeRegionMode.Start:
			base.Output.Write("#region ");
			base.Output.WriteLine(region.RegionText);
			break;
		case CodeRegionMode.End:
			base.Output.WriteLine("#endregion");
			break;
		}
	}

	private void GenerateGenericsParameters(CodeTypeParameterCollection parameters)
	{
		int count = parameters.Count;
		if (count != 0)
		{
			base.Output.Write('<');
			for (int i = 0; i < count - 1; i++)
			{
				base.Output.Write(parameters[i].Name);
				base.Output.Write(", ");
			}
			base.Output.Write(parameters[count - 1].Name);
			base.Output.Write('>');
		}
	}

	private void GenerateGenericsConstraints(CodeTypeParameterCollection parameters)
	{
		int count = parameters.Count;
		if (count == 0)
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < count; i++)
		{
			CodeTypeParameter codeTypeParameter = parameters[i];
			bool flag2 = codeTypeParameter.Constraints.Count != 0;
			base.Output.WriteLine();
			if (!flag2 && !codeTypeParameter.HasConstructorConstraint)
			{
				continue;
			}
			if (!flag)
			{
				base.Indent++;
				flag = true;
			}
			base.Output.Write("where ");
			base.Output.Write(codeTypeParameter.Name);
			base.Output.Write(" : ");
			for (int j = 0; j < codeTypeParameter.Constraints.Count; j++)
			{
				if (j > 0)
				{
					base.Output.Write(", ");
				}
				OutputType(codeTypeParameter.Constraints[j]);
			}
			if (codeTypeParameter.HasConstructorConstraint)
			{
				if (flag2)
				{
					base.Output.Write(", ");
				}
				base.Output.Write("new");
				if (flag2)
				{
					base.Output.Write(" ");
				}
				base.Output.Write("()");
			}
		}
		if (flag)
		{
			base.Indent--;
		}
	}

	private string GetTypeArguments(CodeTypeReferenceCollection collection)
	{
		StringBuilder stringBuilder = new StringBuilder(" <");
		foreach (CodeTypeReference item in collection)
		{
			stringBuilder.Append(GetTypeOutput(item));
			stringBuilder.Append(", ");
		}
		stringBuilder.Length--;
		stringBuilder[stringBuilder.Length - 1] = '>';
		return stringBuilder.ToString();
	}

	private void OutputTypeArguments(CodeTypeReferenceCollection typeArguments, StringBuilder sb, int count)
	{
		if (count == 0)
		{
			return;
		}
		if (typeArguments.Count == 0)
		{
			sb.Append("<>");
			return;
		}
		sb.Append('<');
		sb.Append(GetTypeOutput(typeArguments[0]));
		for (int i = 1; i < count; i++)
		{
			sb.Append(", ");
			sb.Append(GetTypeOutput(typeArguments[i]));
		}
		sb.Append('>');
	}

	private string GetSafeName(string id)
	{
		if (keywordsTable == null)
		{
			FillKeywordTable();
		}
		if (keywordsTable.Contains(id))
		{
			return "@" + id;
		}
		return id;
	}

	private static void FillKeywordTable()
	{
		keywordsTable = new Hashtable();
		string[] array = keywords;
		foreach (string text in array)
		{
			keywordsTable.Add(text, text);
		}
	}
}

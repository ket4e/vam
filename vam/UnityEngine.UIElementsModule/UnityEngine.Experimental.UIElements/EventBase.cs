using System;

namespace UnityEngine.Experimental.UIElements;

/// <summary>
///   <para>The base class for all UIElements events.</para>
/// </summary>
public abstract class EventBase : IDisposable
{
	/// <summary>
	///   <para>Flags to describe the characteristics of an event.</para>
	/// </summary>
	[Flags]
	public enum EventFlags
	{
		/// <summary>
		///   <para>Empty value.</para>
		/// </summary>
		None = 0,
		/// <summary>
		///   <para>Event will bubble up the propagation path (i.e. from the target parent up to the visual tree root).</para>
		/// </summary>
		Bubbles = 1,
		/// <summary>
		///   <para>Event will be sent down the propagation path during the capture phase (i.e. from the visual tree root down to the target parent).</para>
		/// </summary>
		Capturable = 2,
		/// <summary>
		///   <para>Execution of default behavior for this event can be cancelled.</para>
		/// </summary>
		Cancellable = 4,
		/// <summary>
		///   <para>Event has been instanciated from the event pool.</para>
		/// </summary>
		Pooled = 0x100
	}

	private static long s_LastTypeId = 0L;

	protected IEventHandler m_CurrentTarget;

	private Event m_ImguiEvent;

	private Vector2 m_OriginalMousePosition;

	/// <summary>
	///   <para>The time at which the event was created.</para>
	/// </summary>
	public long timestamp { get; private set; }

	/// <summary>
	///   <para>Flags for the event.</para>
	/// </summary>
	protected EventFlags flags { get; set; }

	/// <summary>
	///   <para>Returns whether this event type bubbles up in the event propagation path.</para>
	/// </summary>
	public bool bubbles => (flags & EventFlags.Bubbles) != 0;

	/// <summary>
	///   <para>Return whether this event is sent down the event propagation path during the capture phase.</para>
	/// </summary>
	public bool capturable => (flags & EventFlags.Capturable) != 0;

	/// <summary>
	///   <para>The target for this event. The is the visual element that received the event. Unlike currentTarget, target does not change when the event is sent to elements along the propagation path.</para>
	/// </summary>
	public IEventHandler target { get; internal set; }

	/// <summary>
	///   <para>Return true if StopPropagation() has been called for this event.</para>
	/// </summary>
	public bool isPropagationStopped { get; private set; }

	/// <summary>
	///   <para>Return true if StopImmediatePropagation() has been called for this event.</para>
	/// </summary>
	public bool isImmediatePropagationStopped { get; private set; }

	/// <summary>
	///   <para>Return true if the default actions should not be executed for this event.</para>
	/// </summary>
	public bool isDefaultPrevented { get; private set; }

	/// <summary>
	///   <para>The current propagation phase.</para>
	/// </summary>
	public PropagationPhase propagationPhase { get; internal set; }

	/// <summary>
	///   <para>The current target of the event. The current target is the element in the propagation path for which event handlers are currently being executed.</para>
	/// </summary>
	public virtual IEventHandler currentTarget
	{
		get
		{
			return m_CurrentTarget;
		}
		internal set
		{
			m_CurrentTarget = value;
			if (imguiEvent != null && currentTarget is VisualElement ele)
			{
				imguiEvent.mousePosition = ele.WorldToLocal(m_OriginalMousePosition);
			}
		}
	}

	/// <summary>
	///   <para>Return whether the event is currently being dispatched to visual element. An event can not be redispatched while being dispatched. If you need to recursively redispatch an event, you should use a copy.</para>
	/// </summary>
	public bool dispatch { get; internal set; }

	/// <summary>
	///   <para>The IMGUIEvent at the source of this event. This can be null as not all events are generated by IMGUI.</para>
	/// </summary>
	public Event imguiEvent
	{
		get
		{
			return m_ImguiEvent;
		}
		protected set
		{
			m_ImguiEvent = value;
			if (m_ImguiEvent != null)
			{
				originalMousePosition = value.mousePosition;
			}
		}
	}

	/// <summary>
	///   <para>The original mouse position of the IMGUI event, before it is transformed to the local element coordinates. </para>
	/// </summary>
	public Vector2 originalMousePosition
	{
		get
		{
			return m_OriginalMousePosition;
		}
		private set
		{
			m_OriginalMousePosition = value;
		}
	}

	protected EventBase()
	{
		Init();
	}

	/// <summary>
	///   <para>Register an event class to the event type system.</para>
	/// </summary>
	/// <returns>
	///   <para>The type ID.</para>
	/// </returns>
	protected static long RegisterEventType()
	{
		return ++s_LastTypeId;
	}

	/// <summary>
	///   <para>Get the type id for this event instance.</para>
	/// </summary>
	/// <returns>
	///   <para>The type ID.</para>
	/// </returns>
	public abstract long GetEventTypeId();

	/// <summary>
	///   <para>Stop the propagation of this event. The event will not be sent to any further element in the propagation path. Further event handlers on the current target will be executed.</para>
	/// </summary>
	public void StopPropagation()
	{
		isPropagationStopped = true;
	}

	/// <summary>
	///   <para>Immediately stop the propagation of this event. The event will not be sent to any further event handlers on the current target or on any other element in the propagation path.</para>
	/// </summary>
	public void StopImmediatePropagation()
	{
		isPropagationStopped = true;
		isImmediatePropagationStopped = true;
	}

	/// <summary>
	///   <para>Call this function to prevent the execution of the default actions for this event.</para>
	/// </summary>
	public void PreventDefault()
	{
		if ((flags & EventFlags.Cancellable) == EventFlags.Cancellable)
		{
			isDefaultPrevented = true;
		}
	}

	/// <summary>
	///   <para>Reset the event members to their initial value.</para>
	/// </summary>
	protected virtual void Init()
	{
		timestamp = DateTime.Now.Ticks;
		flags = EventFlags.None;
		target = null;
		isPropagationStopped = false;
		isImmediatePropagationStopped = false;
		isDefaultPrevented = false;
		propagationPhase = PropagationPhase.None;
		m_CurrentTarget = null;
		dispatch = false;
		imguiEvent = null;
		originalMousePosition = Vector2.zero;
	}

	/// <summary>
	///   <para>Implementation of IDisposable.</para>
	/// </summary>
	public abstract void Dispose();
}
/// <summary>
///   <para>Generic base class for events, implementing event pooling and automatic registration to the event type system.</para>
/// </summary>
public abstract class EventBase<T> : EventBase where T : EventBase<T>, new()
{
	private static readonly long s_TypeId = EventBase.RegisterEventType();

	private static readonly EventPool<T> s_Pool = new EventPool<T>();

	public static long TypeId()
	{
		return s_TypeId;
	}

	public static T GetPooled()
	{
		T result = s_Pool.Get();
		result.Init();
		result.flags |= EventFlags.Pooled;
		return result;
	}

	protected static void ReleasePooled(T evt)
	{
		if ((evt.flags & EventFlags.Pooled) == EventFlags.Pooled)
		{
			s_Pool.Release(evt);
			evt.flags &= ~EventFlags.Pooled;
			evt.target = null;
		}
	}

	public override void Dispose()
	{
		ReleasePooled((T)this);
	}

	public override long GetEventTypeId()
	{
		return s_TypeId;
	}
}
